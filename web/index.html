<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">
    <title>Pilot</title>
</head>
<body style="background-color: black; margin: 0">
<div id="pad"
     style="display: grid; grid-template: 'a . b' auto '. . .' 1fr 'c c c' auto / auto 1fr auto; height: 100%; position: fixed; width: 100%">
    <div style="align-content: center; align-items: center; display: grid; grid-area: a; height: 40px; justify-items: center; margin: 10px; position: relative; width: 40px">
        <input id="keyboard"
               style="background-color: white; border: 0; box-sizing: border-box; border-radius: 50%; caret-color: transparent; cursor: pointer; height: 100%; outline: 0; position: absolute; width: 100%"/>
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"
             style="pointer-events: none; position: absolute">
            <path d="M160-200q-33 0-56.5-23.5T80-280v-400q0-33 23.5-56.5T160-760h640q33 0 56.5 23.5T880-680v400q0 33-23.5 56.5T800-200H160Zm0-80h640v-400H160v400Zm160-40h320v-80H320v80ZM200-440h80v-80h-80v80Zm120 0h80v-80h-80v80Zm120 0h80v-80h-80v80Zm120 0h80v-80h-80v80Zm120 0h80v-80h-80v80ZM200-560h80v-80h-80v80Zm120 0h80v-80h-80v80Zm120 0h80v-80h-80v80Zm120 0h80v-80h-80v80Zm120 0h80v-80h-80v80ZM160-280v-400 400Z"/>
        </svg>
    </div>
    <div id="scroll" data-checked
         style="align-content: center; background-color: white; border-radius: 50%; cursor: pointer; display: grid; grid-area: b; height: 40px; justify-items: center; margin: 10px; width: 40px">
        <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#000000"
             style="pointer-events: none">
            <path d="M480-80 310-250l57-57 73 73v-206H235l73 72-58 58L80-480l169-169 57 57-72 72h206v-206l-73 73-57-57 170-170 170 170-57 57-73-73v206h205l-73-72 58-58 170 170-170 170-57-57 73-73H520v205l72-73 58 58L480-80Z"/>
        </svg>
    </div>
    <div style="display: grid; gap: 10px; grid-area: c; grid-template-columns: minmax(0, 100px) 30px minmax(0, 100px); height: 40px; justify-self: center; margin: 10px">
        <div id="button1" style="background-color: white; border-radius: 5px; cursor: pointer"></div>
        <div id="button2" style="background-color: white; border-radius: 5px; cursor: pointer"></div>
        <div id="button3" style="background-color: white; border-radius: 5px; cursor: pointer"></div>
    </div>
</div>
<script>
    const pad = document.getElementById('pad')
    const scroll = document.getElementById('scroll')
    const keyboard = document.getElementById('keyboard')
    const button1 = document.getElementById('button1')
    const button2 = document.getElementById('button2')
    const button3 = document.getElementById('button3')
    const elementsOnTop = [scroll, keyboard, button1, button2, button3]
    const webSocket = new WebSocket('/')
    const touchScreen = 'ontouchstart' in window || navigator.maxTouchPoints
    const input = {
        mouseMove: 0,
        mouseButton1: 1,
        scroll: 2,
        keyboard: 3,
        mouseButton1Down: 4,
        mouseButton1Up: 5,
        mouseButton2Down: 6,
        mouseButton2Up: 7,
        mouseButton3Down: 8,
        mouseButton3Up: 9,
    }
    let lastTickTime
    webSocket.onopen = () => {
        for (const elementOnTop of elementsOnTop) {
            elementOnTop.onpointerdown = (event) => event.stopPropagation()
            elementOnTop.onpointermove = (event) => event.stopPropagation()
            elementOnTop.onpointerup = (event) => event.stopPropagation()
        }
        let initX, initY
        let x, y
        let pointerId
        let moveHistory
        pad.onpointerdown = (event) => {
            keyboard.blur()
            lastTickTime = 0
            initX = event.clientX
            initY = event.clientY
            x = initX
            y = initY
            pointerId = event.pointerId
            moveHistory = []
        }
        const scrollThreshold = 25
        pad.ontouchmove = (event) => {
            event.preventDefault()
        }
        pad.onpointermove = (event) => {
            if (event.pointerId !== pointerId) {
                return
            }
            let newX = event.clientX
            let newY = event.clientY
            if (scroll.dataset.checked) {
                if (!isTick()) {
                    return
                }
                const movementX = newX - x
                const movementY = newY - y
                let scrollX, scrollY
                if (Math.abs(movementX) > scrollThreshold) {
                    scrollX = movementX > 0 ? 1 : -1
                }
                if (Math.abs(movementY) > scrollThreshold) {
                    scrollY = movementY > 0 ? 1 : -1
                }
                if (scrollX != null || scrollY != null) {
                    sendScrollInput(scrollX ?? 0, scrollY ?? 0)
                    x = newX
                    y = newY
                }
            } else {
                if (touchScreen) {
                    if (moveHistory.length === 0) {
                        x = newX
                        y = newY
                    }
                    moveHistory.push([newX, newY])
                    if (moveHistory.length > 3) {
                        moveHistory.shift()
                    }
                    if (!isTick()) {
                        return
                    }
                    newX = moveHistory.map((p) => p[0]).reduce((a, b) => a + b) / moveHistory.length
                    newY = moveHistory.map((p) => p[1]).reduce((a, b) => a + b) / moveHistory.length
                    newX = Math.trunc(newX)
                    newY = Math.trunc(newY)
                } else {
                    if (!isTick()) {
                        return
                    }
                }
                const movementX = newX - x
                const movementY = newY - y
                sendMouseMoveInput(movementX, movementY)
                x = newX
                y = newY
            }
        }
        pad.onpointerup = (event) => {
            if (event.pointerId !== pointerId) {
                return
            }
            pointerId = null
            if (!scroll.dataset.checked) {
                if (initX === x && initY === y) {
                    sendMouseButton1Input()
                }
            }
        }
        let button1Active = false
        button1.onpointerdown = (event) => {
            event.stopPropagation()
            if (!button1Active) {
                button1Active = true
                button1.style.backgroundColor = 'silver'
                sendMouseButton1DownInput()
            }
        }
        button1.onpointerup = (event) => {
            event.stopPropagation()
            if (button1Active) {
                sendMouseButton1UpInput()
                button1.style.backgroundColor = 'white'
                button1Active = false
            }
        }
        button1.onpointerleave = (event) => {
            event.stopPropagation()
            if (button1Active) {
                sendMouseButton1UpInput()
                button1.style.backgroundColor = 'white'
                button1Active = false
            }
        }
        let button2Active = false
        button2.onpointerdown = (event) => {
            event.stopPropagation()
            if (!button2Active) {
                button2Active = true
                button2.style.backgroundColor = 'silver'
                sendMouseButton2DownInput()
            }
        }
        button2.onpointerup = (event) => {
            event.stopPropagation()
            if (button2Active) {
                sendMouseButton2UpInput()
                button2.style.backgroundColor = 'white'
                button2Active = false
            }
        }
        button2.onpointerleave = (event) => {
            event.stopPropagation()
            if (button2Active) {
                sendMouseButton2UpInput()
                button2.style.backgroundColor = 'white'
                button2Active = false
            }
        }
        let button3Active = false
        button3.onpointerdown = (event) => {
            event.stopPropagation()
            if (!button3Active) {
                button3Active = true
                button3.style.backgroundColor = 'silver'
                sendMouseButton3DownInput()
            }
        }
        button3.onpointerup = (event) => {
            event.stopPropagation()
            if (button3Active) {
                sendMouseButton3UpInput()
                button3.style.backgroundColor = 'white'
                button3Active = false
            }
        }
        button3.onpointerleave = (event) => {
            event.stopPropagation()
            if (button3Active) {
                sendMouseButton3UpInput()
                button3.style.backgroundColor = 'white'
                button3Active = false
            }
        }
    }
    keyboard.onfocus = () => {
        keyboard.style.outline = '4px green solid'
    }
    keyboard.onblur = () => {
        keyboard.style.outline = '0'
    }
    keyboard.oninput = () => {
        handleKeyboardInput(keyboard.value)
        keyboard.value = ''
    }
    keyboard.onkeydown = (event) => {
        handleKeyboardKey(event.key)
    }
    scroll.onclick = () => {
        const checked = scroll.dataset.checked
        if (checked) {
            scroll.dataset.checked = ''
            scroll.style.outline = '0'
        } else {
            scroll.dataset.checked = 'true'
            scroll.style.outline = '4px green solid'
        }
    }
    webSocket.onclose = () => {
        for (const elementOnTop of elementsOnTop) {
            elementOnTop.onpointerdown = null
            elementOnTop.onpointermove = null
            elementOnTop.onpointerup = null
        }
        pad.onpointerdown = null
        pad.onpointermove = null
        pad.onpointerup = null
        button1.onpointerdown = null
        button1.onpointerup = null
        button1.onpointerleave = null
        button2.onpointerdown = null
        button2.onpointerup = null
        button2.onpointerleave = null
        button3.onpointerdown = null
        button3.onpointerup = null
        button3.onpointerleave = null
        keyboard.onfocus = null
        keyboard.onblur = null
        keyboard.oninput = null
        keyboard.onkeydown = null
        scroll.onclick = null
    }
    const tickInterval = 20
    /**
     * @returns {boolean}
     */
    const isTick = () => {
        if (Date.now() - tickInterval > lastTickTime) {
            lastTickTime = Date.now()
            return true
        }
        return false
    }
    /**
     * @param {string} keyboardInput
     */
    const handleKeyboardInput = (keyboardInput) => {
        for (const key of keyboardInput.split('')) {
            let keys = ' !"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'
            let index = keys.indexOf(key)
            if (index >= 0) {
                const keyCode = index + 32
                sendKeyboardInput(keyCode)
                continue
            }
            keys = 'xĄxŁxxŚxxxxxŹxxŻxąxłxxśxxxxxźxxżxxxxxxĆxxxĘxxxxxxŃxÓxxxxxxxxxxxxxxxxxxćxxxęxxxxxxńxó'
            index = keys.indexOf(key)
            if (index >= 0) {
                const keyCode = index + 160
                sendKeyboardInput(keyCode)
            }
        }
    }
    /**
     * @param {string} keyboardKey
     */
    const handleKeyboardKey = (keyboardKey) => {
        const keys = [
            'Escape',
            'F1',
            'F2',
            'F3',
            'F4',
            'F5',
            'F6',
            'F7',
            'F8',
            'F9',
            'F10',
            'F11',
            'F12',
            'Home',
            'End',
            'Insert',
            'Delete',
            'Backspace',
            'Enter',
            'PageUp',
            'PageDown',
            'ArrowUp',
            'ArrowDown',
            'ArrowLeft',
            'ArrowRight',
            'CapsLock',
            'Tab',
        ]
        const index = keys.findIndex((key) => key === keyboardKey)
        if (index >= 0) {
            const keyCode = index + 127
            sendKeyboardInput(keyCode)
        }
    }
    /**
     * @param {number} scrollX
     * @param {number} scrollY
     */
    const sendScrollInput = (scrollX, scrollY) => {
        scrollX = Math.max(0, Math.min(255, scrollX + 128))
        scrollY = Math.max(0, Math.min(255, scrollY + 128))
        const bytes = new Uint8Array([input.scroll, scrollX, scrollY])
        webSocket.send(bytes)
    }
    /**
     * @param {number} movementX
     * @param {number} movementY
     */
    const sendMouseMoveInput = (movementX, movementY) => {
        movementX = Math.max(0, Math.min(255, movementX + 128))
        movementY = Math.max(0, Math.min(255, movementY + 128))
        const bytes = new Uint8Array([input.mouseMove, movementX, movementY])
        webSocket.send(bytes)
    }
    const sendMouseButton1Input = () => {
        const bytes = new Uint8Array([input.mouseButton1])
        webSocket.send(bytes)
    }
    /**
     * @param {number} keyCode
     */
    const sendKeyboardInput = (keyCode) => {
        const bytes = new Uint8Array([input.keyboard, keyCode])
        webSocket.send(bytes)
    }
    const sendMouseButton1DownInput = () => {
        const bytes = new Uint8Array([input.mouseButton1Down])
        webSocket.send(bytes)
    }
    const sendMouseButton1UpInput = () => {
        const bytes = new Uint8Array([input.mouseButton1Up])
        webSocket.send(bytes)
    }
    const sendMouseButton2DownInput = () => {
        const bytes = new Uint8Array([input.mouseButton2Down])
        webSocket.send(bytes)
    }
    const sendMouseButton2UpInput = () => {
        const bytes = new Uint8Array([input.mouseButton2Up])
        webSocket.send(bytes)
    }
    const sendMouseButton3DownInput = () => {
        const bytes = new Uint8Array([input.mouseButton3Down])
        webSocket.send(bytes)
    }
    const sendMouseButton3UpInput = () => {
        const bytes = new Uint8Array([input.mouseButton3Up])
        webSocket.send(bytes)
    }
</script>
</body>
</html>